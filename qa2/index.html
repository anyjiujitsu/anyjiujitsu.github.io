<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DIRECTORY 5</title>
</head>
<body>

<h1>DIRECTORY 5</h1>
<div id="status">Loading…</div>
<div id="out"></div>
<pre id="meta"></pre>

<script>
(async function () {
  const statusEl = document.getElementById("status");
  const outEl = document.getElementById("out");
  const metaEl = document.getElementById("meta");

  const CSV_CANDIDATES = [
    "data/directory.csv",
    "./data/directory.csv",
    "/data/directory.csv"
  ];

  // NOTE: CREATED stays in the schema for validation + later use, but is hidden in the UI.
  const EXPECTED = ["STATE", "CITY", "NAME", "IG", "SAT", "SUN", "OTA", "CREATED"];

  const toText = (v) => String(v ?? "").trim();

  // ------------------ Normalizers ------------------

  function properCaseBasic(input) {
    const s = toText(input);
    if (!s) return "";
    if (/^[a-zA-Z]{2}$/.test(s)) return s.toUpperCase();
    return s
      .toLowerCase()
      .split(" ")
      .filter(Boolean)
      .map(w =>
        w.split("-").map(p =>
          p.split("'").map(x =>
            x ? x[0].toUpperCase() + x.slice(1) : ""
          ).join("'")
        ).join("-")
      )
      .join(" ");
  }

  const lowerCaseIG = (v) => toText(v).toLowerCase();

  function formatTimeHMM_A(input) {
    let s = toText(input);
    if (!s) return "";

    const raw = s;
    s = s.toLowerCase().replace(/\./g, "").replace(/\s+/g, "");

    // If a range is present, keep as-is for now (we'll standardize ranges later if desired)
    if (s.includes("-") || s.includes("–") || s.includes("to")) return raw;

    // 24h like "21:15"
    let m = s.match(/^([01]?\d|2[0-3]):([0-5]\d)$/);
    if (m) {
      let h = parseInt(m[1], 10);
      const mm = m[2];
      const ap = h >= 12 ? "PM" : "AM";
      h = h % 12 || 12;
      return `${h}:${mm} ${ap}`;
    }

    // "9am", "9:30am", "9a", "9:30p"
    m = s.match(/^(\d{1,2})(?::([0-5]\d))?(a|p|am|pm)$/);
    if (m) {
      let h = parseInt(m[1], 10);
      const mm = m[2] ?? "00";
      const ap = m[3].startsWith("p") ? "PM" : "AM";
      h = h % 12 || 12;
      return `${h}:${mm} ${ap}`;
    }

    return raw;
  }

  function normOTA(v) {
    const s = toText(v).toUpperCase();
    if (!s) return "";
    if (["Y", "YES", "TRUE", "1"].includes(s)) return "Y";
    if (["N", "NO", "FALSE", "0"].includes(s)) return "N";
    return "";
  }

  function normCreated(v) {
    const s = toText(v);
    if (!s) return "";
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) return s;

    const d = new Date(s);
    if (isNaN(d)) return s;

    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    const yyyy = d.getFullYear();
    return `${mm}/${dd}/${yyyy}`;
  }

  // ------------------ Load CSV ------------------

  let csvText = "";
  let usedUrl = "";
  let lastErr = null;

  for (const url of CSV_CANDIDATES) {
    try {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} (${url})`);
      const txt = await res.text();
      if (txt.trim()) {
        csvText = txt;
        usedUrl = url;
        break;
      }
    } catch (e) {
      lastErr = e;
    }
  }

  if (!csvText.trim()) {
    statusEl.textContent = "CSV load error ❌";
    outEl.innerHTML = `<pre>${String(lastErr)}</pre>`;
    metaEl.textContent = `Tried:\n- ${CSV_CANDIDATES.join("\n- ")}`;
    return;
  }

  const firstLine = csvText.split(/\r?\n/).find(l => l.trim()) || "";
  const DELIM = firstLine.includes("\t") ? "\t" : ",";

  function parseDelimited(text, d) {
    const rows = [];
    let row = [], cur = "", inQ = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const n = text[i + 1];

      if (inQ) {
        if (c === '"' && n === '"') { cur += '"'; i++; }
        else if (c === '"') inQ = false;
        else cur += c;
      } else {
        if (c === '"') inQ = true;
        else if (c === d) { row.push(cur); cur = ""; }
        else if (c === "\n") {
          row.push(cur); cur = "";
          if (row.some(v => toText(v))) rows.push(row);
          row = [];
        } else if (c !== "\r") cur += c;
      }
    }

    row.push(cur);
    if (row.some(v => toText(v))) rows.push(row);
    return rows;
  }

  const matrix = parseDelimited(csvText, DELIM);
  if (!matrix.length) {
    statusEl.textContent = "CSV empty ❌";
    return;
  }

  const headers = matrix[0].map(h => toText(h).toUpperCase());
  const idx = Object.fromEntries(headers.map((h, i) => [h, i]));

  const missing = EXPECTED.filter(h => !(h in idx));
  if (missing.length) {
    statusEl.textContent = "Header mismatch ❌";
    outEl.innerHTML = `<pre>Missing: ${missing.join(", ")}\nFound: ${headers.join(", ")}</pre>`;
    return;
  }

  const rows = matrix.slice(1)
    .filter(r => r.some(c => toText(c)))
    .map(r => ({
      STATE:   properCaseBasic(r[idx.STATE]),
      CITY:    properCaseBasic(r[idx.CITY]),
      NAME:    properCaseBasic(r[idx.NAME]),
      IG:      lowerCaseIG(r[idx.IG]),
      SAT:     formatTimeHMM_A(r[idx.SAT]),
      SUN:     formatTimeHMM_A(r[idx.SUN]),
      OTA:     normOTA(r[idx.OTA]),
      CREATED: normCreated(r[idx.CREATED])
    }));

  // ------------------ Render (stacked layout) ------------------
  // Layout per row (top row OTA only, as requested):
  // [ NAME ] [ CITY ] [ Sat. SAT ] [ OTA dot ]
  // [  IG  ] [STATE ] [ Sun. SUN ] [ (blank) ]

  function otaDot(ota) {
    if (ota === "Y") return `<span style="display:inline-block;font-size:18px;line-height:1;color:green;">●</span>`;
    if (ota === "N") return `<span style="display:inline-block;font-size:18px;line-height:1;color:red;">●</span>`;
    return "";
  }

  const wrap = document.createElement("div");

  rows.forEach(obj => {
    const card = document.createElement("div");
    card.style.display = "grid";
    card.style.gridTemplateColumns = "1fr 1fr 1fr 60px";
    card.style.border = "1px solid #000";
    card.style.marginBottom = "8px";

    function cell(text, opts = {}) {
      const d = document.createElement("div");
      d.style.padding = "10px";
      d.style.borderRight = opts.noRightBorder ? "none" : "1px solid #000";
      d.style.borderBottom = opts.noBottomBorder ? "none" : "1px solid #000";
      d.textContent = text ?? "";
      return d;
    }

    function labelValueCell(label, value, isTopRow) {
      const d = document.createElement("div");
      d.style.padding = "10px";
      d.style.borderRight = "1px solid #000";
      d.style.borderBottom = isTopRow ? "1px solid #000" : "none";
      d.innerHTML =
        `<span style="font-weight:700;">${label}</span>` +
        `&nbsp;&nbsp;` +
        `<span>${(value ?? "")}</span>`;
      return d;
    }

    // Row 1
    card.appendChild(cell(obj.NAME, { }));                    // col 1
    card.appendChild(cell(obj.CITY, { }));                    // col 2
    card.appendChild(labelValueCell("Sat.", obj.SAT, true));  // col 3

    const otaCell = document.createElement("div");            // col 4
    otaCell.style.padding = "10px";
    otaCell.style.borderBottom = "1px solid #000";
    otaCell.style.borderRight = "none";
    otaCell.innerHTML = otaDot(obj.OTA); // top row only
    card.appendChild(otaCell);

    // Row 2
    const igCell = cell(obj.IG, { noBottomBorder: true });
    igCell.style.borderBottom = "none";
    card.appendChild(igCell);

    const stateCell = cell(obj.STATE, { noBottomBorder: true });
    stateCell.style.borderBottom = "none";
    card.appendChild(stateCell);

    card.appendChild(labelValueCell("Sun.", obj.SUN, false)); // col 3, row 2

    const blank = document.createElement("div");              // col 4, row 2
    blank.style.padding = "10px";
    blank.style.borderRight = "none";
    blank.style.borderBottom = "none";
    blank.innerHTML = ""; // intentionally blank
    card.appendChild(blank);

    wrap.appendChild(card);
  });

  statusEl.textContent = `Loaded ${rows.length} rows (stacked layout + OTA dot)`;
  outEl.innerHTML = "";
  outEl.appendChild(wrap);

  metaEl.textContent =
    `Loaded from: ${usedUrl}\n` +
    `Delimiter: ${DELIM === "\t" ? "TAB" : "COMMA"}`;
})();
</script>

</body>
</html>
