<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DIRECTORY 6</title>
</head>
<body>

<h1>DIRECTORY 6</h1>
<div id="status">Loading…</div>
<div id="out"></div>
<pre id="meta"></pre>

<script>
(async function () {
  const statusEl = document.getElementById("status");
  const outEl = document.getElementById("out");
  const metaEl = document.getElementById("meta");

  const CSV_CANDIDATES = ["data/directory.csv", "./data/directory.csv", "/data/directory.csv"];

  // Required columns in the CSV (CREATED required but not displayed)
  const REQUIRED = ["STATE", "CITY", "NAME", "IG", "SAT", "SUN", "OTA", "CREATED"];

  const toText = (v) => String(v ?? "").trim();

  // -------- Normalizers (same intent as before) --------

  function properCaseBasic(input) {
    const s = toText(input);
    if (!s) return "";
    if (/^[a-zA-Z]{2}$/.test(s)) return s.toUpperCase();
    return s
      .toLowerCase()
      .split(" ")
      .filter(Boolean)
      .map(w =>
        w.split("-").map(p =>
          p.split("'").map(x => (x ? x[0].toUpperCase() + x.slice(1) : "")).join("'")
        ).join("-")
      )
      .join(" ");
  }

  const lowerCaseIG = (v) => toText(v).toLowerCase();

  function formatTimeHMM_A(input) {
    let raw = toText(input);
    if (!raw) return "";

    let s = raw.toLowerCase().replace(/\./g, "").replace(/\s+/g, "");

    // Keep ranges as-is for now
    if (s.includes("-") || s.includes("–") || s.includes("to")) return raw;

    // 24h "21:15"
    let m = s.match(/^([01]?\d|2[0-3]):([0-5]\d)$/);
    if (m) {
      let h = parseInt(m[1], 10);
      const mm = m[2];
      const ap = h >= 12 ? "PM" : "AM";
      h = h % 12 || 12;
      return `${h}:${mm} ${ap}`;
    }

    // "9am", "9:30am", "9a", "9:30p"
    m = s.match(/^(\d{1,2})(?::([0-5]\d))?(a|p|am|pm)$/);
    if (m) {
      let h = parseInt(m[1], 10);
      const mm = m[2] ?? "00";
      const ap = m[3].startsWith("p") ? "PM" : "AM";
      h = h % 12 || 12;
      return `${h}:${mm} ${ap}`;
    }

    return raw;
  }

  function normOTA(v) {
    const s = toText(v).toUpperCase();
    if (!s) return "";
    if (["Y", "YES", "TRUE", "1"].includes(s)) return "Y";
    if (["N", "NO", "FALSE", "0"].includes(s)) return "N";
    return "";
  }

  // More predictable CREATED parsing:
  // Accepts: MM/DD/YYYY, M/D/YYYY, YYYY-MM-DD, and falls back to original text.
  function normCreated(v) {
    const s = toText(v);
    if (!s) return "";

    // MM/DD/YYYY
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) return s;

    // M/D/YYYY or MM/D/YYYY etc.
    let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (m) {
      const mm = String(parseInt(m[1], 10)).padStart(2, "0");
      const dd = String(parseInt(m[2], 10)).padStart(2, "0");
      const yyyy = m[3];
      return `${mm}/${dd}/${yyyy}`;
    }

    // YYYY-MM-DD
    m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (m) {
      return `${m[2]}/${m[3]}/${m[1]}`;
    }

    // Fallback: try Date, but only if it produces a valid date
    const d = new Date(s);
    if (!isNaN(d)) {
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const yyyy = d.getFullYear();
      return `${mm}/${dd}/${yyyy}`;
    }

    return s;
  }

  // -------- CSV loading + parsing --------

  async function loadCSV() {
    let lastErr = null;

    for (const url of CSV_CANDIDATES) {
      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} (${url})`);
        const txt = await res.text();
        if (txt.trim()) return { text: txt, usedUrl: url };
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error("Failed to load CSV");
  }

  function detectDelimiter(csvText) {
    const firstLine = csvText.split(/\r?\n/).find(l => l.trim()) || "";
    return firstLine.includes("\t") ? "\t" : ",";
  }

  function parseDelimited(text, d) {
    const rows = [];
    let row = [], cur = "", inQ = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const n = text[i + 1];

      if (inQ) {
        if (c === '"' && n === '"') { cur += '"'; i++; }
        else if (c === '"') inQ = false;
        else cur += c;
      } else {
        if (c === '"') inQ = true;
        else if (c === d) { row.push(cur); cur = ""; }
        else if (c === "\n") {
          row.push(cur); cur = "";
          if (row.some(v => toText(v))) rows.push(row);
          row = [];
        } else if (c !== "\r") cur += c;
      }
    }
    row.push(cur);
    if (row.some(v => toText(v))) rows.push(row);
    return rows;
  }

  function buildIndex(headersRow) {
    const headers = headersRow.map(h => toText(h).toUpperCase());
    const idx = Object.fromEntries(headers.map((h, i) => [h, i]));
    return { headers, idx };
  }

  // -------- Render (same layout, faster HTML string) --------

  function otaDotHTML(ota) {
    if (ota === "Y") return `<span style="display:inline-block;font-size:18px;line-height:1;color:green;">●</span>`;
    if (ota === "N") return `<span style="display:inline-block;font-size:18px;line-height:1;color:red;">●</span>`;
    return "";
  }

  // Minimal inline styles (still “unstyled”, just structure)
  const cardStyle = "display:grid;grid-template-columns:1fr 1fr 1fr 60px;border:1px solid #000;margin-bottom:8px;";
  const cellTop = "padding:10px;border-right:1px solid #000;border-bottom:1px solid #000;";
  const cellTopNoRight = "padding:10px;border-bottom:1px solid #000;";
  const cellBottom = "padding:10px;border-right:1px solid #000;";
  const cellBottomNoRight = "padding:10px;";

  function lvCell(label, value, topRow) {
    const base = topRow ? cellTop : cellBottom;
    return `<div style="${base}"><span style="font-weight:700;">${label}</span>&nbsp;&nbsp;<span>${escapeHTML(value ?? "")}</span></div>`;
  }

  function escapeHTML(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function renderCards(rows) {
    let html = "";

    for (const r of rows) {
      html += `
        <div style="${cardStyle}">
          <div style="${cellTop}">${escapeHTML(r.NAME)}</div>
          <div style="${cellTop}">${escapeHTML(r.CITY)}</div>
          ${lvCell("Sat.", r.SAT, true)}
          <div style="${cellTopNoRight}">${otaDotHTML(r.OTA)}</div>

          <div style="${cellBottom}">${escapeHTML(r.IG)}</div>
          <div style="${cellBottom}">${escapeHTML(r.STATE)}</div>
          ${lvCell("Sun.", r.SUN, false)}
          <div style="${cellBottomNoRight}"></div>
        </div>
      `;
    }

    outEl.innerHTML = html;
  }

  // -------- Main --------

  try {
    const { text, usedUrl } = await loadCSV();
    const delim = detectDelimiter(text);
    const matrix = parseDelimited(text, delim);

    if (!matrix.length) throw new Error("CSV empty");

    const { headers, idx } = buildIndex(matrix[0]);

    const missing = REQUIRED.filter(h => !(h in idx));
    if (missing.length) {
      statusEl.textContent = "Header mismatch ❌";
      outEl.innerHTML = `<pre>Missing: ${missing.join(", ")}\nFound: ${headers.join(", ")}</pre>`;
      metaEl.textContent = `Loaded from: ${usedUrl}\nDelimiter: ${delim === "\t" ? "TAB" : "COMMA"}`;
      return;
    }

    const rows = matrix.slice(1)
      .filter(r => r.some(c => toText(c)))
      .map(r => ({
        STATE:   properCaseBasic(r[idx.STATE]),
        CITY:    properCaseBasic(r[idx.CITY]),
        NAME:    properCaseBasic(r[idx.NAME]),
        IG:      lowerCaseIG(r[idx.IG]),
        SAT:     formatTimeHMM_A(r[idx.SAT]),
        SUN:     formatTimeHMM_A(r[idx.SUN]),
        OTA:     normOTA(r[idx.OTA]),
        CREATED: normCreated(r[idx.CREATED])
      }));

    statusEl.textContent = `Loaded ${rows.length} rows (stacked layout + OTA dot)`;
    renderCards(rows);

    metaEl.textContent =
      `Loaded from: ${usedUrl}\n` +
      `Delimiter: ${delim === "\t" ? "TAB" : "COMMA"}`;
  } catch (e) {
    statusEl.textContent = "CSV load error ❌";
    outEl.innerHTML = `<pre>${String(e)}</pre>`;
    metaEl.textContent = `Tried:\n- ${CSV_CANDIDATES.join("\n- ")}`;
  }
})();
</script>

</body>
</html>
