<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DIRECTORY 2</title>
</head>
<body>

<h1>DIRECTORY 2</h1>
<div id="status">Loading…</div>
<div id="out"></div>
<pre id="meta"></pre>

<script>
(async function () {
  const statusEl = document.getElementById("status");
  const outEl = document.getElementById("out");
  const metaEl = document.getElementById("meta");

  const CSV_CANDIDATES = [
    "data/directory.csv",
    "./data/directory.csv",
    "/data/directory.csv"
  ];

  const EXPECTED = ["STATE", "CITY", "NAME", "IG", "SAT", "SUN", "OTA"];

  const toText = (v) => String(v ?? "").trim();

  // OTA is the only boolean field (Y/N/blank)
  const normOTA = (v) => {
    const s = toText(v).toUpperCase();
    if (!s) return "";
    if (["Y", "YES", "TRUE", "1"].includes(s)) return "Y";
    if (["N", "NO", "FALSE", "0"].includes(s)) return "N";
    return "";
  };

  let csvText = "";
  let usedUrl = "";
  let lastErr = null;

  for (const url of CSV_CANDIDATES) {
    try {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} (${url})`);
      const txt = await res.text();
      if (txt.trim()) {
        csvText = txt;
        usedUrl = url;
        break;
      }
    } catch (e) {
      lastErr = e;
    }
  }

  if (!csvText.trim()) {
    statusEl.textContent = "CSV load error ❌";
    outEl.innerHTML = `<pre>${String(lastErr)}</pre>`;
    metaEl.textContent = `Tried:\n- ${CSV_CANDIDATES.join("\n- ")}`;
    return;
  }

  // Detect delimiter (TAB preferred)
  const firstLine = csvText.split(/\r?\n/).find(l => l.trim()) || "";
  const DELIM = firstLine.includes("\t") ? "\t" : ",";

  function parseDelimited(text, d) {
    const rows = [];
    let row = [], cur = "", inQ = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const n = text[i + 1];

      if (inQ) {
        if (c === '"' && n === '"') { cur += '"'; i++; }
        else if (c === '"') inQ = false;
        else cur += c;
      } else {
        if (c === '"') inQ = true;
        else if (c === d) { row.push(cur); cur = ""; }
        else if (c === "\n") {
          row.push(cur); cur = "";
          if (row.some(v => toText(v))) rows.push(row);
          row = [];
        } else if (c !== "\r") cur += c;
      }
    }

    row.push(cur);
    if (row.some(v => toText(v))) rows.push(row);
    return rows;
  }

  const matrix = parseDelimited(csvText, DELIM);
  if (!matrix.length) {
    statusEl.textContent = "CSV empty ❌";
    metaEl.textContent = `Loaded from: ${usedUrl}\nDelimiter: ${DELIM === "\t" ? "TAB" : "COMMA"}`;
    return;
  }

  const headers = matrix[0].map(h => toText(h).toUpperCase());
  const idx = Object.fromEntries(headers.map((h, i) => [h, i]));

  const missing = EXPECTED.filter(h => !(h in idx));
  if (missing.length) {
    statusEl.textContent = "Header mismatch ❌";
    outEl.innerHTML = `
<pre>
Missing: ${missing.join(", ")}
Found: ${headers.join(", ")}
</pre>`;
    metaEl.textContent = `Loaded from: ${usedUrl}\nDelimiter: ${DELIM === "\t" ? "TAB" : "COMMA"}`;
    return;
  }

  const rows = matrix.slice(1)
    .filter(r => r.some(c => toText(c)))
    .map(r => ({
      STATE: toText(r[idx.STATE]),
      CITY:  toText(r[idx.CITY]),
      NAME:  toText(r[idx.NAME]),
      IG:    toText(r[idx.IG]),
      SAT:   toText(r[idx.SAT]),
      SUN:   toText(r[idx.SUN]),
      OTA:   normOTA(r[idx.OTA])
    }));

  const table = document.createElement("table");
  table.border = "1";
  table.cellPadding = "6";
  table.style.borderCollapse = "collapse";

  const thead = document.createElement("thead");
  const trh = document.createElement("tr");
  EXPECTED.forEach(h => {
    const th = document.createElement("th");
    th.textContent = h;
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement("tbody");
  rows.forEach(obj => {
    const tr = document.createElement("tr");
    EXPECTED.forEach(h => {
      const td = document.createElement("td");
      td.textContent = obj[h];
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  statusEl.textContent = `Loaded ${rows.length} rows (OTA normalized)`;
  outEl.innerHTML = "";
  outEl.appendChild(table);

  metaEl.textContent =
    `Loaded from: ${usedUrl}\n` +
    `Delimiter: ${DELIM === "\t" ? "TAB" : "COMMA"}\n` +
    `Columns: ${headers.join(", ")}`;
})();
</script>

</body>
</html>
